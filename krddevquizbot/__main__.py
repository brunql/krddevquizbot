#!/usr/bin/env python3
import logging
import os
import random
from datetime import datetime

from telegram import Update, Poll, User
from telegram.constants import ParseMode
from telegram.ext import Application, PollHandler, PollAnswerHandler, CommandHandler, ContextTypes, MessageHandler, filters
from telegram.helpers import escape_markdown

from krddevquizbot.questions import QUESTIONS


logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
# set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

# DB
USERS_STATS = {}
POLLS = {}

ADMINS = ["brunql", "darkdef_pr"]

POLL_OPEN_PERIOD_SECONDS = 10

CURRENT_QUESTION_INDEX = 0
CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID = 0
CURRENT_MEM_INDEX = 0
MEMS_DIR_PATH = "mems"

SKIPMESSAGES = [
  "–°–ª–∏—Ç—å—Å—è!",
  "–°–ø–∏—Ç—å—Å—è!",
  "–õ–∞–¥–Ω–æ —è —Å–¥–∞—é—Å—å...",
  "–≠—Ç–æ –∂–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–æ–ø—Ä–æ—Å!",
  "–í–æ—Ç –∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç!",
  "–ì–∞–ª–∞–∫—Ç–∏–∫–∞ –≤ –æ–ø–∞—Å–Ω–æ—Å—Ç–µ!",
  "–¢—ã—Ü!",
  "–î–∞–≤–∞–π —Ç—ã —Å–º–æ–∂–µ—à—å!",
  "–î—É–º–∞—Ç—å –ª–µ–Ω—å",
  "–ü–æ–¥–µ—Ä–∂–∏—Ç–µ –º–æ–µ –ø–∏–≤–æ!",
]


def get_random_skip_message():
  return random.choice(SKIPMESSAGES)


def is_admin(update: Update) -> bool:
  return update.effective_user.username in ADMINS


def get_name(user_id: int) -> str:
  user = USERS_STATS.get(user_id, {}).get('user')
  return user.name if user else ""


def get_user_score(user_id: int) -> int:
  return USERS_STATS.get(user_id, {}).get('score', 0)


def fmt_score(score: float) -> str:
  return f"{score:.1f}"


def fmt_user_score(user_id: int) -> int:
  return fmt_score(get_user_score(user_id))


def init_user(update: Update):
  user = update.effective_user
  if user.id not in USERS_STATS:
    USERS_STATS[user.id] = {'user': user, 'correct': 0, 'fail': 0, 'score': 0}


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  init_user(update)

  user = update.effective_user

  await update.message.reply_text(
    f"""–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–ª—É–±! üëç
    
üî• –û–∂–∏–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∏ —Å—Ç–∞—Ä—Ç—É–µ–º! üòé 

–ü–µ—Ä–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ –∫–ª—É–±–∞ - –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –≤—Å–µ–≥–¥–∞ —Å–∫—Ä—ã—Ç, –ø–æ–¥–≥–ª—è–¥—ã–≤–∞—Ç—å –Ω–µ—Ç —Å–º—ã—Å–ª–∞ - –¥—É–º–∞–π —Å–∞–º! üòà

–í—Ç–æ—Ä–æ–µ –ø—Ä–∞–≤–∏–ª–æ –∫–ª—É–±–∞ - –¥–ª—è —Ç–µ–ª–µ–≥—Ä–∞–º–º–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤—ã–π, –Ω–æ –º—ã —Ç–æ –∑–Ω–∞–µ–º, —á—Ç–æ —ç—Ç–æ –Ω–µ —Ç–∞–∫! ü§ì

–¢—Ä–µ—Ç—å–µ –ø—Ä–∞–≤–∏–ª–æ –∫–ª—É–±–∞ - –æ—Ç–≤–µ—Ç–∏–ª –Ω–∞ –≤–æ–ø—Ä–æ—Å - –≤—ã–ø–∏–ª! üç∫

–ñ–µ–ª–∞–µ–º —É–¥–∞—á–∏! üéÉ ü§ù
""")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  init_user(update)
  await update.message.reply_text("üôà –ü–æ–º–æ—â–∏ –Ω–µ –±—É–¥–µ—Ç –º–æ–∂–Ω–æ –¥–∞–∂–µ –Ω–µ –Ω–∞–¥–µ—è—Ç—å—Å—è. ü§™")  


async def broadcast_message(text: str, context: ContextTypes.DEFAULT_TYPE):
  for user_id in USERS_STATS.keys():
    try:
      await context.bot.send_message(chat_id=user_id, text=f"üê≥ broadcast: {text}")
    except Exception as ex:
      logging.error(f"broadcast_message: send_message fail: {ex} name={get_name(user_id)}")


async def broadcast_next_mem(context: ContextTypes.DEFAULT_TYPE):
  global CURRENT_MEM_INDEX
  
  mems = os.listdir(MEMS_DIR_PATH)
  if len(mems) == 0:
    logging.error("broadcast_next_mem: no mems found")
    return
  
  if CURRENT_MEM_INDEX >= len(mems):
    CURRENT_MEM_INDEX = 0

  mem_filename = mems[CURRENT_MEM_INDEX]

  CURRENT_MEM_INDEX += 1

  for user_id in USERS_STATS.keys():
    try:
      await context.bot.send_photo(
        chat_id=user_id, 
        photo=open(os.path.join(MEMS_DIR_PATH, mem_filename), 'rb'), 
        caption="üê≥ broadcast: #include <image.h>"
      )
    except Exception as ex:
      logging.error(f"broadcast_next_mem: send_photo fail: {ex} name={get_name(user_id)}")


async def admin_start_quiz_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:  
  global CURRENT_QUESTION_INDEX
 
  init_user(update)

  if not is_admin(update):
    await update.message.reply_text("üò≠ –ó–∞–ø—É—Å–∫ –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∞–º.")
    return
  
  CURRENT_QUESTION_INDEX = 0
  await broadcast_message("–ü—Ä–∏–≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –º—ã –Ω–∞—á–∏–Ω–∞–µ–º! üî•", context)


async def admin_next_question_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  global CURRENT_QUESTION_INDEX
  global CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID

  CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID = 0

  init_user(update)

  if not is_admin(update):
    await update.message.reply_text("üíä –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞. –û–∂–∏–¥–∞–π—Ç–µ –Ω–∞ –ª–∏–Ω–∏–∏.")
    return

  if CURRENT_QUESTION_INDEX >= len(QUESTIONS):
    await broadcast_message("–£—Ä–∞! üçæ Quiz –∑–∞–≤–µ—Ä—à–µ–Ω! ü¶Ñ", context)
    await update.message.reply_text("–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É: /admin_stats")
    return

  question = QUESTIONS[CURRENT_QUESTION_INDEX]

  question['answers_count'] = 0
  
  for user_id in USERS_STATS.keys():
    try:
      msg = await context.bot.send_poll(
        user_id, 
        question=f"{CURRENT_QUESTION_INDEX+1} / {len(QUESTIONS)}. {question['question']}", 
        options=[get_random_skip_message()] + question["options"], 
        type=Poll.QUIZ, 
        correct_option_id=0, # always set zero
        protect_content=True,
        open_period=POLL_OPEN_PERIOD_SECONDS,
      )

      POLLS[msg.poll.id] = {"user_id": user_id, "message_id": msg.id, "start_time": datetime.now()}

    except Exception as ex:
      logging.error(f"admin_next_question_command: broadcast send_poll fail: {ex} name={get_name(user_id)}")

  CURRENT_QUESTION_INDEX += 1

  context.job_queue.run_once(show_first_right_answered_user, POLL_OPEN_PERIOD_SECONDS + 2)


async def show_first_right_answered_user(context: ContextTypes.DEFAULT_TYPE):
  prefix = [
      "–û–ø–ø–∞! {name} —É–∂–µ –æ—Ç–≤–µ—Ç–∏–ª! üî•", 
      "–£ {name} —Å–∞–º–∞—è –±—ã—Å—Ç—Ä–∞—è ü¶æ –ª–∞–ø–∫–∞ –Ω–∞ –¥–∏–∫–æ–º –≤–æ—Å—Ç–æ–∫–µ!", 
      "–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å username! request_id={name} traceback=not found", 
      "–ö–∞–∂–µ—Ç—Å—è {name} –Ω–∞—Å –≤–ª–æ–º–∞–ª, –Ω—É –∏ –ª–∞–¥–Ω–æ... üç∫ \n# docker kill krddevquizbot", 
      "–ê {name} —Ç–æ –º–æ–ª–æ–¥–µ—Ü! ‚ö°Ô∏è", 
      "{name}, —Å–ª—É—á–∞–π–Ω–æ –Ω–∞–∂–∞–ª? üßê",
      "–£–≤–∞–∂–∞–µ–º—ã–π, {name}! –í–∞—à –∑–∞–ø—Ä–æ—Å –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ, –±–ª–∏–∂–∞–π—à–∏–π –æ—Å–≤–æ–±–æ–¥–∏–≤—à–∏–π—Å—è —Ä–æ–±–æ—Ç –≤–∞–º –Ω–µ –æ—Ç–≤–µ—Ç–∏—Ç. üôà",
      "{name}, –ø—Ä–∞–≤–∞ –∫—É–ø–∏–ª? üò± –ü—Ä–∏—Å—Ç–µ–≥–Ω–∏—Ç–µ—Å—å —Ç—É—Ç –≤–∑–ª–µ—Ç–∞—é—Ç! üõ´",
      "–î—É–º–∞–µ—Ç—Å—è –º–Ω–µ —á—Ç–æ —É {name} –µ—Å—Ç—å –≤—Å–µ —à–∞–Ω—Å—ã –Ω–∞ –ø–æ–±–µ–¥—É –≤–µ–¥—å —ç—Ç–æ - ü§ñ",
      "{name}, –æ—Å–≤–æ–±–æ–¥–∏–ª—Å—è? –° —Ç–µ–±—è –º–µ–º–∞—Å–∏–∫! üëª",
      "{name}, –ø—Å—Å! üêç –±—Ä–æ, –¥–∞–≤–∞–π –≤—Å–µ–º —Å–∫–∞–∂–µ–º, —á—Ç–æ —ç—Ç–æ—Ç –±–æ—Ç –Ω–∞–ø–∏—Å–∞–Ω –Ω–∞ PHP?",
    ]

  msg = random.choice(prefix)
  user_id = CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID
  if user_id:
    text = msg.format(name=get_name(user_id))    
    await broadcast_message(text, context)
    await broadcast_next_mem(context)
  else:
    await broadcast_message("ü§ñ –ö –≤–µ–ª–∏–∫–æ–º—É —Å–æ–∂–∞–ª–µ–Ω–∏—é –Ω–∏–∫—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª. –ú–µ–º–æ–≤ –Ω–µ –±—É–¥–µ—Ç.", context)


async def receive_quiz_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  global CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID

  if update.poll.is_closed:
    logging.error("receive_quiz_answer: poll.is_closed")
    return

  poll = POLLS.get(update.poll.id, {})
  user_id = poll.get("user_id", 0)
  if not user_id:
    logging.error(f"receive_quiz_answer: poll for user not found: name={get_name(user_id)}")
    return

    
  qs = list(filter(lambda x: x["question"] in update.poll.question, QUESTIONS))
  if len(qs) != 1:
    logging.error(f"receive_quiz_answer: question not found: {update.poll.question} name={get_name(user_id)}")
    return

  question = qs[0]

  # Found real correct option id
  correct_option_id = question["correct_option_number"]

  is_correct = update.poll.options[correct_option_id].voter_count > 0

  user_info = USERS_STATS.get(user_id, {})  
  if not user_info:
    logging.error(f"receive_quiz_answer: user in USERS_STATS not found: user_id={user_id}")
    return

  start_time = poll.get("start_time")
  if not start_time:
    logging.error(f"receive_quiz_answer: start_time in poll for user not found: name={get_name(user_id)}")
    return
  
  score = 100 - (datetime.now() - start_time).total_seconds()
  if score < 0:
    score = 1

  if is_correct:
    user_info['correct'] += 1
    USERS_STATS[user_id]['score'] += score
    
    if not CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID:
      CURRENT_QUESTION_FIRST_RIGHT_ANSWER_USER_ID = user_id
  else:
    user_info['fail'] += 1

  await context.bot.delete_message(chat_id=user_id, message_id=poll.get("message_id", 0))

  if 'answers_count' not in question:
    question['answers_count'] = 0

  question['answers_count'] += 1
  

async def admin_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  init_user(update)
  
  if not is_admin(update):
    await update.message.reply_text("‚úçÔ∏è –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤—Ä—É—á–Ω—É—é, —ç—Ç–æ –≤–∞–º –Ω–µ –¥–∂–µ–π—Å–æ–Ω—ã –≤ –∫—Ä—É–¥–∞—Ö –ø–µ—Ä–µ–∫–ª–∞–¥—ã–≤–∞—Ç—å! üå≠ üò±")
    return

  users_sorted = USERS_STATS.values()
  users_sorted = list(sorted(users_sorted, key=lambda x: x["score"], reverse=True))
  users_sorted = list(sorted(users_sorted, key=lambda x: x["correct"], reverse=True))

  stats = ""
  for i, x in enumerate(users_sorted):
    if i == 0: stats += "ü§ì "
    if i == 1: stats += "üî• "
    if i == 2: stats += "üëæ "
    stats += f"{i+1}: {x['user'].full_name} @{x['user'].username}  {x['correct']}üëç  {x['fail']}üëé (score: {fmt_score(x['score'])})\n"

  msg = f"""
–ü–æ–±–µ–¥–∏–ª–∞ –¥—Ä—É–∂–±–∞! ü§ù üòá

{stats}

–î–ª—è —Å–±—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –Ω–∞–ø–∏—à–∏—Ç–µ –æ—Ç –∞–¥–º–∏–Ω–∞ "–°–±—Ä–æ—Å–∏—Ç—å —Å—á–µ—Ç—á–∏–∫–∏".

{CURRENT_QUESTION_INDEX } / {len(QUESTIONS)}
"""

  await update.message.reply_text(msg)


async def admin_answers_count_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  init_user(update)

  if not is_admin(update):
    await update.message.reply_text("üßæ –£ –≤–∞—Å –ø–ª–æ—Ö–æ–π –∫—Ä–µ–¥–∏—Ç–Ω—ã–π —Å–∫–æ—Ä–∏–Ω–≥, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –¥—Ä—É–≥–æ–π –±–∞–Ω–∫.")
    return
  
  msg = "```\n"

  for i, q in enumerate(QUESTIONS):
    msg += f"{str(i+1).zfill(2)}. –ü–æ–ª—É—á–µ–Ω–æ –æ—Ç–≤–µ—Ç–æ–≤: {q.get('answers_count', 0)}\n"

  msg += "```"

  await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN_V2)


async def admin_next_mem(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  init_user(update)

  if not is_admin(update):
    await update.message.reply_text("No. Just no.")
    return

  await broadcast_next_mem(context)


async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
  if not is_admin(update):
    await update.message.reply_text("–õ–∏–Ω–∏—è –∑–∞–Ω—è—Ç–∞! –ó–∞–π–¥–∏—Ç–µ –ø–æ–∑–∂–µ ü§°")
    return
  
  if update.message.text == "–°–±—Ä–æ—Å–∏—Ç—å —Å—á–µ—Ç—á–∏–∫–∏":
    for user_id in USERS_STATS.keys():
      USERS_STATS[user_id]["correct"] = 0
      USERS_STATS[user_id]["fail"] = 0

    await update.message.reply_text("–ì–æ—Ç–æ–≤–æ")

  global POLL_OPEN_PERIOD_SECONDS
  if update.message.text == "–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å":
    if POLL_OPEN_PERIOD_SECONDS == 10:
      POLL_OPEN_PERIOD_SECONDS = 60
    else:
      POLL_OPEN_PERIOD_SECONDS = 10

    await update.message.reply_text(f"–ì–æ—Ç–æ–≤–æ POLL_OPEN_PERIOD_SECONDS={POLL_OPEN_PERIOD_SECONDS}")


if __name__ == "__main__":
  BOT_TOKEN = os.environ.get("BOT_TOKEN")
  application = Application.builder().token(BOT_TOKEN).build()

  application.add_handler(CommandHandler("start", start_command))
  application.add_handler(CommandHandler("help", help_command))

  application.add_handler(CommandHandler("admin_start_quiz", admin_start_quiz_command))
  application.add_handler(CommandHandler("admin_next_question", admin_next_question_command))
  application.add_handler(CommandHandler("admin_stats", admin_stats_command))
  application.add_handler(CommandHandler("admin_answers_count", admin_answers_count_command))
  application.add_handler(CommandHandler("admin_next_mem", admin_next_mem))
  
  application.add_handler(MessageHandler(filters.TEXT, message_handler))

  application.add_handler(PollHandler(receive_quiz_answer))

  application.run_polling(allowed_updates=Update.ALL_TYPES)
